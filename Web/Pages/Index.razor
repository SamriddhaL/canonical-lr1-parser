@page "/"
@using CanonicalLR1Parser
@using System.Text
@implements IDisposable

<PageTitle>Canonical LR(1) Parser Demo</PageTitle>

<style>
    @@import url('https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600&display=swap');
    
    body {
        font-family: 'Inter', sans-serif;
        margin: 0;
        padding: 0;
    }
    
    .hero-section {
        background: #2c3e50;
        color: white;
        padding: 30px;
        text-align: center;
        border-bottom: 4px solid #3498db;
    }
    
    .hero-title {
        font-size: 2em;
        margin: 0;
        font-weight: 600;
    }
    
    .hero-subtitle {
        font-size: 1em;
        margin: 8px 0 0 0;
        opacity: 0.9;
    }
    
    .control-panel {
        position: sticky;
        top: 0;
        background: white;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 100;
        border-bottom: 2px solid #3498db;
    }
    
    .controls-row {
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
    }
    
    .btn {
        padding: 10px 24px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s;
        font-family: 'Inter', sans-serif;
    }
    
    .btn-primary {
        background: #3498db;
        color: white;
    }
    
    .btn-primary:hover:not(:disabled) {
        background: #2980b9;
    }
    
    .btn-success {
        background: #27ae60;
        color: white;
    }
    
    .btn-warning {
        background: #e67e22;
        color: white;
    }
    
    .btn-secondary {
        background: #7f8c8d;
        color: white;
    }
    
    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 16px;
        background: #f8f9fa;
        border-radius: 4px;
    }
    
    .speed-slider {
        width: 150px;
    }
    
    .progress-container {
        flex: 1;
        min-width: 200px;
    }
    
    .progress-text {
        font-weight: 600;
        color: #495057;
        margin-bottom: 5px;
        font-size: 14px;
    }
    
    .progress-bar-wrapper {
        background: #e9ecef;
        height: 8px;
        border-radius: 4px;
        overflow: hidden;
    }
    
    .progress-bar-fill {
        background: #3498db;
        height: 100%;
        transition: width 0.3s ease;
    }
    
    .step-container {
        margin: 20px auto;
        max-width: 1400px;
        padding: 20px;
        background: white;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-left: 4px solid #3498db;
        animation: slideIn 0.3s ease-out;
    }
    
    @@keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(-10px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    .step-title {
        font-size: 1.3em;
        color: #2c3e50;
        margin-bottom: 15px;
        font-weight: 600;
        border-bottom: 2px solid #ecf0f1;
        padding-bottom: 10px;
    }
    
    .completed-step {
        opacity: 0.6;
        border-left-color: #27ae60;
    }
    
    .completed-step .step-title {
        color: #7f8c8d;
    }
    
    .current-step {
        background: #fff9e6;
        border-left-color: #e67e22;
    }
    
    .current-step .step-title {
        color: #e67e22;
    }
    
    .state-box {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
        animation: fadeInUp 0.3s ease-out;
    }
    
    @@keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .state-header {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #3498db;
    }
    
    .item {
        font-family: 'Fira Code', monospace;
        padding: 6px 10px;
        margin: 4px 0;
        background: white;
        border-radius: 3px;
        color: #2c3e50;
        font-size: 0.9em;
    }
    
    .action-cell {
        padding: 8px 12px;
        border-radius: 4px;
        margin: 4px;
        display: inline-block;
        font-family: 'Fira Code', monospace;
        font-weight: 500;
        font-size: 0.9em;
    }
    
    .reduce-action {
        background: #d4edda;
        color: #155724;
    }
    
    .shift-action {
        background: #cce5ff;
        color: #004085;
    }
    
    .goto-action {
        background: #f8d7da;
        color: #721c24;
    }
    
    .parse-step-row {
        display: grid;
        grid-template-columns: 60px 200px 250px 200px 250px;
        gap: 10px;
        padding: 10px;
        border-bottom: 1px solid #e9ecef;
        font-family: 'Fira Code', monospace;
        font-size: 0.9em;
    }
    
    .parse-step-header {
        font-weight: 600;
        background: #34495e;
        color: white;
        padding: 10px;
        border-radius: 4px 4px 0 0;
    }
    
    .parse-step-current {
        background: #fff3cd;
        font-weight: 600;
    }
    
    .status-badge {
        display: inline-block;
        padding: 10px 20px;
        border-radius: 4px;
        font-weight: 600;
        font-size: 1em;
        margin-top: 15px;
    }
    
    .status-success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    
    .status-error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }
    
    .summary-box {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 4px;
        margin-top: 15px;
        font-family: 'Fira Code', monospace;
        line-height: 1.6;
        border: 1px solid #dee2e6;
    }
    
    pre {
        font-family: 'Fira Code', monospace;
        line-height: 1.5;
        margin: 0;
    }
    
    .content-wrapper {
        padding: 20px;
        background: #f8f9fa;
        min-height: calc(100vh - 200px);
    }
</style>

<div class="hero-section">
    <h1 class="hero-title">Canonical LR(1) Parser</h1>
    <p class="hero-subtitle">Interactive Parser Construction Demo</p>
</div>

<div class="control-panel">
    <div class="controls-row">
        @if (!isRunning && currentStep == 0)
        {
            <button class="btn btn-primary" @onclick="StartAutoPlay">Start Demo</button>
        }
        else if (isRunning)
        {
            <button class="btn btn-warning" @onclick="Pause">Pause</button>
        }
        else if (!isRunning && currentStep > 0 && !isDemoComplete)
        {
            <button class="btn btn-success" @onclick="Resume">Resume</button>
        }
        
        <button class="btn btn-secondary" @onclick="Reset">Reset</button>
        
        <div class="speed-control">
            <span>Speed:</span>
            <input type="range" min="100" max="2000" step="100" @bind="speed" @bind:event="oninput" class="speed-slider" />
            <span>@(speed)ms</span>
        </div>
        
        <div class="progress-container">
            <div class="progress-text">@progressMessage</div>
            <div class="progress-bar-wrapper">
                <div class="progress-bar-fill" style="width: @(progressPercentage)%"></div>
            </div>
        </div>
    </div>
    
    <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #ecf0f1;">
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
            <span style="font-weight: 600; color: #495057;">Parse Custom Input:</span>
            <input type="text" @bind="customInput" placeholder="Enter input string (e.g., id = * id)" 
                   style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; flex: 1; min-width: 250px;" />
            <button class="btn btn-primary" @onclick="ParseCustomInput">Parse</button>
        </div>
    </div>
</div>

<div class="content-wrapper">
    @if (currentStep >= 1)
    {
        <div class="step-container @(currentStep > 1 ? "completed-step" : "current-step")">
            <div class="step-title">Step 1: Grammar Definition</div>
            <pre>@(isCustomDemoMode ? customDemoGrammarText : grammarText)</pre>
        </div>
    }

    @if (currentStep >= 2)
    {
        <div class="step-container @(currentStep > 2 ? "completed-step" : "current-step")">
            <div class="step-title">Step 2: FIRST Sets Computation</div>
            <pre>@(isCustomDemoMode ? customDemoFirstSetsText : firstSetsText)</pre>
        </div>
    }

    @if (currentStep >= 3)
    {
        <div class="step-container @(currentStep > 3 ? "completed-step" : "current-step")">
            <div class="step-title">Step 3: Building LR(1) DFA - State Construction (@(currentStateIndex + 1) / @collection.States.Count)</div>
            
            @if (dfaSteps.Any())
            {
                <div style="margin-bottom: 20px; padding: 15px; background: #e8f4f8; border-left: 4px solid #3498db; border-radius: 4px;">
                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 10px;">üîÑ DFA Construction Process</div>
                    <div style="font-family: 'Fira Code', monospace; font-size: 0.9em; color: #495057;">
                        Queue: [@string.Join(", ", dfaSteps[Math.Min(currentStateIndex, dfaSteps.Count - 1)].QueueSnapshot)]<br/>
                        States Created: @(currentStateIndex + 1) / @collection.States.Count<br/>
                        @if (currentStateIndex >= 0 && currentStateIndex < dfaSteps.Count)
                        {
                            var currentDfaStep = dfaSteps[currentStateIndex];
                            <span style="color: #e67e22; font-weight: 600;">Current: Processing State @currentDfaStep.StateId</span>
                            @if (currentDfaStep.ShiftableSymbols.Any())
                            {
                                <br/>
                                <span>Shiftable Symbols: {@string.Join(", ", currentDfaStep.ShiftableSymbols)}</span>
                            }
                        }
                    </div>
                </div>
            }
            
            @for (int i = 0; i <= Math.Min(currentStateIndex, collection.States.Count - 1); i++)
            {
                var state = collection.States[i];
                var dfaStep = i < dfaSteps.Count ? dfaSteps[i] : null;
                var isCurrentState = i == currentStateIndex;
                
                <div class="state-box" style="@(isCurrentState ? "border: 2px solid #e67e22; box-shadow: 0 4px 12px rgba(230, 126, 34, 0.3);" : "")">
                    <div class="state-header" style="@(isCurrentState ? "color: #e67e22; border-bottom-color: #e67e22;" : "")">
                        State @i (@state.Items.Count items) @(isCurrentState ? "‚Üê CURRENT" : "")
                    </div>
                    
                    @if (dfaStep != null && dfaStep.IsNewState)
                    {
                        <div style="background: #d4edda; color: #155724; padding: 6px 10px; margin: 8px 0; border-radius: 3px; font-size: 0.85em;">
                            ‚ú® New state created via GOTO(State @dfaStep.ParentState, @dfaStep.TransitionSymbol)
                        </div>
                    }
                    
                    <div style="margin-top: 8px;">
                        @foreach (var item in state.Items.OrderBy(x => x.Production.LeftHandSide).ThenBy(x => x.DotPosition))
                        {
                            <div class="item">[@item.Production.LeftHandSide ‚Üí @GetItemDisplay(item), @item.Lookahead]</div>
                        }
                    </div>
                    
                    @{
                        var outgoingTransitions = collection.Transitions.Where(t => t.Key.Item1 == i).ToList();
                        if (outgoingTransitions.Any())
                        {
                            <div style="margin-top: 12px; padding: 10px; background: #f8f9fa; border-radius: 3px;">
                                <div style="font-weight: 600; color: #495057; margin-bottom: 6px;">üì§ Transitions from this state:</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    @foreach (var trans in outgoingTransitions)
                                    {
                                        var isTerminal = grammar.Terminals.Contains(trans.Key.Item2);
                                        <div style="@(isTerminal ? "background: #cce5ff; color: #004085;" : "background: #f8d7da; color: #721c24;") padding: 6px 12px; border-radius: 3px; font-family: 'Fira Code', monospace; font-size: 0.85em; font-weight: 500;">
                                            @trans.Key.Item2 ‚Üí S@trans.Value
                                        </div>
                                    }
                                </div>
                            </div>
                        }
                    }
                </div>
            }
        </div>
    }

    @if (currentStep >= 3 && currentStateIndex >= collection.States.Count - 1)
    {
        <div class="step-container" style="border-left-color: #9b59b6;">
            <div class="step-title" style="color: #9b59b6;">Step 3.5: Complete DFA Diagram</div>
            <div style="background: white; padding: 20px; border: 2px solid #dee2e6; border-radius: 8px;">
                <div style="margin-bottom: 15px; font-weight: 600; color: #2c3e50;">üìä DFA State Transition Diagram</div>
                <svg width="100%" height="@(GetDFADiagramHeight())" viewBox="0 0 1200 @(GetDFADiagramHeight())" style="border: 1px solid #e9ecef; border-radius: 4px; background: #fafbfc;">
                    @RenderDFADiagram()
                </svg>
                <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 4px; font-size: 0.9em;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Legend:</div>
                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <div><span style="display: inline-block; width: 12px; height: 12px; background: #3498db; border-radius: 50%; margin-right: 6px;"></span>States</div>
                        <div><span style="display: inline-block; width: 20px; height: 2px; background: #2ecc71; margin-right: 6px; position: relative; top: 5px;"></span>Terminal transitions</div>
                        <div><span style="display: inline-block; width: 20px; height: 2px; background: #e74c3c; margin-right: 6px; position: relative; top: 5px;"></span>Non-terminal transitions</div>
                    </div>
                </div>
            </div>
        </div>
    }
    
    @if (currentStep >= 4)
    {
        <div class="step-container @(currentStep > 4 ? "completed-step" : "current-step")">
            <div class="step-title">Step 4: Parsing Table Construction (@(currentTableStateIndex + 1) / @collection.States.Count)</div>
            
            <h3 style="color: #2c3e50; margin-top: 15px;">ACTION Table</h3>
            <div style="margin-bottom: 10px; padding: 8px; background: #e8f4f8; border-left: 3px solid #3498db; font-size: 0.9em;">
                <strong>Note:</strong> Empty cells (not shown) indicate syntax errors - the parser rejects that input.
            </div>
            @for (int stateId = 0; stateId <= Math.Min(currentTableStateIndex, collection.States.Count - 1); stateId++)
            {
                <div style="margin: 10px 0;">
                    <strong>State @stateId:</strong>
                    @foreach (var terminal in grammar.Terminals.OrderBy(t => t))
                    {
                        var action = parsingTable.GetAction(stateId, terminal);
                        if (action != null)
                        {
                            var cssClass = action.Type == ActionType.Shift ? "shift-action" : 
                                          action.Type == ActionType.Reduce ? "reduce-action" : "action-cell";
                            <span class="action-cell @cssClass">
                                @terminal: @GetActionDisplay(action)
                            </span>
                        }
                    }
                </div>
            }
            
            <h3 style="color: #2c3e50; margin-top: 20px;">GOTO Table</h3>
            @for (int stateId = 0; stateId <= Math.Min(currentTableStateIndex, collection.States.Count - 1); stateId++)
            {
                <div style="margin: 10px 0;">
                    <strong>State @stateId:</strong>
                    @foreach (var nt in grammar.NonTerminals.Where(n => n != "S'").OrderBy(n => n))
                    {
                        var gotoState = parsingTable.GetGoto(stateId, nt);
                        if (gotoState != -1)
                        {
                            <span class="action-cell goto-action">
                                @nt ‚Üí State @gotoState
                            </span>
                        }
                    }
                </div>
            }
            
            @if (currentTableStateIndex >= collection.States.Count - 1)
            {
                <div style="margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 4px; border: 1px solid #c3e6cb;">
                    <strong>Conflict Analysis:</strong> @(parsingTable.HasConflicts ? "CONFLICTS DETECTED" : "NO CONFLICTS - Grammar IS Canonical LR(1)")
                </div>
            }
        </div>
    }

    @if (currentStep >= 5)
    {
        <div class="step-container @(currentStep > 5 ? "completed-step" : "current-step")">
            <div class="step-title">Step 5: Parsing Input String - Step @(currentParseStepIndex + 1) / @(isCustomDemoMode ? customDemoParseSteps.Count : parseSteps.Count)</div>
            <p><strong>Input:</strong> <code style="background: white; padding: 6px 12px; border-radius: 3px; font-family: 'Fira Code', monospace;">@(isCustomDemoMode ? customInput : inputString)</code></p>
            
            <div class="parse-step-header parse-step-row">
                <div>Step</div>
                <div>State Stack</div>
                <div>Symbol Stack</div>
                <div>Remaining Input</div>
                <div>Action</div>
            </div>
            
            @{
                var currentParseList = isCustomDemoMode ? customDemoParseSteps : parseSteps;
                for (int i = 0; i <= Math.Min(currentParseStepIndex, currentParseList.Count - 1); i++)
                {
                    var step = currentParseList[i];
                    <div class="parse-step-row @(i == currentParseStepIndex ? "parse-step-current" : "")">
                        <div>@(i + 1)</div>
                        <div>@string.Join(" ", step.StateStack)</div>
                        <div>@string.Join(" ", step.SymbolStack)</div>
                        <div>@string.Join(" ", step.RemainingInput)</div>
                        <div>@GetActionDisplay(step.Action)</div>
                    </div>
                }
            }
            
            @if (currentParseStepIndex >= (isCustomDemoMode ? customDemoParseSteps.Count - 1 : parseSteps.Count - 1) && (isCustomDemoMode ? customDemoParseSteps.Any() : parseSteps.Any()))
            {
                var lastStep = isCustomDemoMode ? customDemoParseSteps.Last() : parseSteps.Last();
                var isAccepted = lastStep.Action.Type == ActionType.Accept;
                <div class="status-badge @(isAccepted ? "status-success" : "status-error")">
                    @(isAccepted ? "PARSING SUCCESSFUL - INPUT ACCEPTED" : "PARSING FAILED - INPUT REJECTED")
                </div>
            }
        </div>
    }

    @if (currentStep >= 6)
    {
        <div class="step-container @(isCustomDemoMode ? (isDemoComplete ? "completed-step" : "current-step") : (currentStep > 6 ? "completed-step" : "current-step"))">
            <div class="step-title">Step 6: @(isCustomDemoMode ? "Parsing Results" : "Summary & Grammar Semantics")</div>
            <div class="summary-box">
                <pre>@(isCustomDemoMode ? customDemoSummaryText : summaryText)</pre>
            </div>
        </div>
    }
    
    @if (isCustomDemoMode && currentStep >= 5 && customDemoParseSteps.Any())
    {
        <div class="step-container" style="border-left-color: #9b59b6;">
            <div class="step-title" style="color: #9b59b6;">Complete Parsing Trace for: @customInput</div>
            <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; overflow-x: auto;">
                <pre style="margin: 0; font-family: 'Fira Code', monospace; font-size: 0.85em;">Step   State Stack               Symbol Stack                   Input                Action
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@{
    int stepNum = 1;
    foreach (var step in customDemoParseSteps)
    {
        var stateStackStr = string.Join(" ", step.StateStack);
        var symbolStackStr = string.Join(" ", step.SymbolStack);
        var inputStr = string.Join(" ", step.RemainingInput);
        var actionStr = GetActionDisplay(step.Action);
        @($"{stepNum,-6} {stateStackStr,-23} {symbolStackStr,-29} {inputStr,-21} {actionStr}\n");
        stepNum++;
    }
}</pre>
            </div>
        </div>
    }
</div>

@code {
    private int currentStep = 0;
    private int currentStateIndex = -1;
    private int currentTableStateIndex = -1;
    private int currentParseStepIndex = -1;
    private bool isRunning = false;
    private bool isDemoComplete = false;
    private int speed = 500;
    private System.Threading.Timer? timer;
    
    private Grammar grammar = null!;
    private FirstSetComputer firstComputer = null!;
    private LR1Operations operations = null!;
    private CanonicalCollection collection = null!;
    private ParsingTable parsingTable = null!;
    private List<ParseStep> parseSteps = new();
    private string inputString = "id = * id";
    private string customInput = "id = * id";
    private string customParseOutput = "";
    
    // DFA construction tracking
    private List<DFAConstructionStep> dfaSteps = new();
    
    private bool isCustomDemoMode = false;
    private string customDemoGrammarText = "";
    private string customDemoFirstSetsText = "";
    private string customDemoSummaryText = "";
    private List<ParseStep> customDemoParseSteps = new();
    
    private string grammarText = "";
    private string firstSetsText = "";
    private string summaryText = "";
    
    private string progressMessage => GetProgressMessage();
    private double progressPercentage => GetProgressPercentage();
    
    private void StartAutoPlay()
    {
        currentStep = 1;
        isRunning = true;
        isDemoComplete = false;
        
        grammar = new Grammar();
        firstComputer = new FirstSetComputer(grammar);
        operations = new LR1Operations(grammar, firstComputer);
        collection = new CanonicalCollection(grammar, operations);
        
        var sb = new StringBuilder();
        for (int i = 0; i < grammar.Productions.Count; i++)
        {
            sb.AppendLine($"{i}: {grammar.Productions[i]}");
        }
        grammarText = sb.ToString();
        
        StartTimer();
    }
    
    private void StartTimer()
    {
        timer?.Dispose();
        timer = new System.Threading.Timer(async _ => await AdvanceStep(), null, speed, speed);
    }
    
    private async Task AdvanceStep()
    {
        if (isCustomDemoMode)
        {
            await AdvanceCustomStep();
        }
        else
        {
            await InvokeAsync(() =>
            {
                if (!isRunning) return;
                
                if (currentStep == 1)
                {
                    currentStep = 2;
                    var sb = new StringBuilder();
                    var firstSets = firstComputer.GetAllFirstSets();
                    foreach (var nt in grammar.NonTerminals.OrderBy(x => x))
                    {
                        sb.AppendLine($"FIRST({nt}) = {{ {string.Join(", ", firstSets[nt].OrderBy(x => x))} }}");
                    }
                    firstSetsText = sb.ToString();
                }
                else if (currentStep == 2)
                {
                    currentStep = 3;
                    BuildDFAWithSteps();
                    currentStateIndex = 0;
                }
                else if (currentStep == 3 && currentStateIndex < collection.States.Count - 1)
                {
                    currentStateIndex++;
                }
                else if (currentStep == 3)
                {
                    currentStep = 4;
                    parsingTable = new ParsingTable(grammar, collection);
                    parsingTable.ConstructTables();
                    currentTableStateIndex = 0;
                }
                else if (currentStep == 4 && currentTableStateIndex < collection.States.Count - 1)
                {
                    currentTableStateIndex++;
                }
                else if (currentStep == 4)
                {
                    currentStep = 5;
                    var tokens = LR1Parser.Tokenize(inputString);
                    var parser = new LR1Parser(grammar, parsingTable);
                    parseSteps = parser.ParseWithSteps(tokens);
                    currentParseStepIndex = 0;
                }
                else if (currentStep == 5 && currentParseStepIndex < parseSteps.Count - 1)
                {
                    currentParseStepIndex++;
                }
                else if (currentStep == 5)
                {
                    currentStep = 6;
                    var sb = new StringBuilder();
                    sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                    sb.AppendLine("GRAMMAR SEMANTICS");
                    sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                    sb.AppendLine("The grammar treats * as a unary prefix operator (dereference),");
                    sb.AppendLine("NOT as an infix multiplication operator.");
                    sb.AppendLine();
                    sb.AppendLine("Therefore, the string 'id = id * id' is NOT derivable from this");
                    sb.AppendLine("grammar and is correctly REJECTED by the Canonical LR(1) parser.");
                    sb.AppendLine();
                    sb.AppendLine("Valid examples:");
                    sb.AppendLine("  - id = * id    (assign dereference-of-id to id)");
                    sb.AppendLine("  - * * id       (double dereference)");
                    sb.AppendLine("  - id           (just an identifier)");
                    sb.AppendLine();
                    sb.AppendLine("Invalid examples:");
                    sb.AppendLine("  - id = id * id (would require infix * operator)");
                    sb.AppendLine();
                    sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                    sb.AppendLine($"Final Statistics:");
                    sb.AppendLine($"  Total LR(1) States: {collection.States.Count}");
                    sb.AppendLine($"  Total Transitions: {collection.Transitions.Count}");
                    sb.AppendLine($"  Conflicts: {(parsingTable.HasConflicts ? "YES" : "NONE")}");
                    sb.AppendLine($"  Grammar Type: {(parsingTable.HasConflicts ? "NOT Canonical LR(1)" : "Canonical LR(1)")}");
                    sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                    summaryText = sb.ToString();
                    
                    isRunning = false;
                    isDemoComplete = true;
                    timer?.Dispose();
                }
                
                StateHasChanged();
            });
        }
    }
    
    private void Pause()
    {
        isRunning = false;
        timer?.Dispose();
    }
    
    private void Resume()
    {
        isRunning = true;
        StartTimer();
    }
    
    private void Reset()
    {
        isRunning = false;
        isDemoComplete = false;
        currentStep = 0;
        currentStateIndex = -1;
        currentTableStateIndex = -1;
        currentParseStepIndex = -1;
        grammarText = "";
        firstSetsText = "";
        summaryText = "";
        parseSteps.Clear();
        timer?.Dispose();
    }
    
    private string GetProgressMessage()
    {
        if (currentStep == 0) return "Ready to start";
        if (currentStep == 1) return "Loading grammar...";
        if (currentStep == 2) return "Computing FIRST sets...";
        if (currentStep == 3) return $"Building LR(1) states: {currentStateIndex + 1} / {collection.States.Count}";
        if (currentStep == 4) return $"Constructing parsing tables: {currentTableStateIndex + 1} / {collection.States.Count}";
        if (currentStep == 5) return $"Parsing input: step {currentParseStepIndex + 1} / {parseSteps.Count}";
        if (currentStep == 6) return "Demo complete";
        return "";
    }
    
    private double GetProgressPercentage()
    {
        if (currentStep == 0) return 0;
        if (currentStep == 1) return 10;
        if (currentStep == 2) return 20;
        if (currentStep == 3)
        {
            var stateProgress = (currentStateIndex + 1.0) / collection.States.Count * 20;
            return 20 + stateProgress;
        }
        if (currentStep == 4)
        {
            var tableProgress = (currentTableStateIndex + 1.0) / collection.States.Count * 20;
            return 40 + tableProgress;
        }
        if (currentStep == 5)
        {
            var parseProgress = (currentParseStepIndex + 1.0) / parseSteps.Count * 20;
            return 60 + parseProgress;
        }
        if (currentStep == 6) return 100;
        return 0;
    }
    
    private string GetItemDisplay(LR1Item item)
    {
        var rhs = new List<string>(item.Production.RightHandSide);
        rhs.Insert(item.DotPosition, "‚Ä¢");
        return string.Join(" ", rhs);
    }
    
    private string GetActionDisplay(ParserAction action)
    {
        return action.Type switch
        {
            ActionType.Shift => $"Shift {action.Value}",
            ActionType.Reduce => $"Reduce {action.Value}",
            ActionType.Accept => "Accept",
            _ => "Error"
        };
    }
    
    public void Dispose()
    {
        timer?.Dispose();
    }
    
    private void BuildDFAWithSteps()
    {
        dfaSteps.Clear();
        collection = new CanonicalCollection(grammar, operations);
        collection.States.Clear();
        collection.Transitions.Clear();
        
        // Create initial state
        var initialItem = new LR1Item(grammar.Productions[0], 0, "$");
        var initialItems = new HashSet<LR1Item> { initialItem };
        var initialState = new LR1State(operations.Closure(initialItems));
        initialState.StateId = 0;
        
        collection.States.Add(initialState);
        
        var stateQueue = new Queue<int>();
        stateQueue.Enqueue(0);
        
        var stateMap = new Dictionary<string, int>();
        stateMap[GetStateKey(initialState)] = 0;
        
        dfaSteps.Add(new DFAConstructionStep
        {
            StateId = 0,
            IsNewState = true,
            ParentState = -1,
            TransitionSymbol = "",
            QueueSnapshot = new List<int>(stateQueue),
            ShiftableSymbols = new List<string>()
        });
        
        while (stateQueue.Count > 0)
        {
            var currentStateId = stateQueue.Dequeue();
            var currentState = collection.States[currentStateId];
            
            var symbols = operations.GetShiftableSymbols(currentState.Items);
            
            dfaSteps[currentStateId].ShiftableSymbols = new List<string>(symbols);
            
            foreach (var symbol in symbols)
            {
                var gotoItems = operations.Goto(currentState.Items, symbol);
                
                if (gotoItems.Count == 0)
                    continue;
                
                var gotoState = new LR1State(gotoItems);
                string stateKey = GetStateKey(gotoState);
                
                int targetStateId;
                
                if (stateMap.ContainsKey(stateKey))
                {
                    targetStateId = stateMap[stateKey];
                }
                else
                {
                    targetStateId = collection.States.Count;
                    gotoState.StateId = targetStateId;
                    collection.States.Add(gotoState);
                    stateMap[stateKey] = targetStateId;
                    stateQueue.Enqueue(targetStateId);
                    
                    dfaSteps.Add(new DFAConstructionStep
                    {
                        StateId = targetStateId,
                        IsNewState = true,
                        ParentState = currentStateId,
                        TransitionSymbol = symbol,
                        QueueSnapshot = new List<int>(stateQueue),
                        ShiftableSymbols = new List<string>()
                    });
                }
                
                collection.Transitions[(currentStateId, symbol)] = targetStateId;
            }
        }
    }
    
    private string GetStateKey(LR1State state)
    {
        var sortedItems = state.Items.OrderBy(i => i.ToString()).ToList();
        return string.Join("|", sortedItems.Select(i => i.ToString()));
    }
    
    private int GetDFADiagramHeight()
    {
        int stateCount = collection.States.Count;
        int rows = (int)Math.Ceiling(stateCount / 4.0);
        return Math.Max(400, rows * 150 + 100);
    }
    
    private RenderFragment RenderDFADiagram() => builder =>
    {
        if (collection?.States == null || !collection.States.Any())
            return;
        
        int statesPerRow = 4;
        int stateRadius = 30;
        int horizontalSpacing = 280;
        int verticalSpacing = 150;
        int startX = 150;
        int startY = 80;
        
        var statePositions = new Dictionary<int, (int x, int y)>();
        
        // Calculate positions
        for (int i = 0; i < collection.States.Count; i++)
        {
            int row = i / statesPerRow;
            int col = i % statesPerRow;
            int x = startX + col * horizontalSpacing;
            int y = startY + row * verticalSpacing;
            statePositions[i] = (x, y);
        }
        
        // Draw transitions
        foreach (var transition in collection.Transitions)
        {
            var (fromState, symbol) = transition.Key;
            var toState = transition.Value;
            
            if (!statePositions.ContainsKey(fromState) || !statePositions.ContainsKey(toState))
                continue;
            
            var (x1, y1) = statePositions[fromState];
            var (x2, y2) = statePositions[toState];
            
            bool isTerminal = grammar.Terminals.Contains(symbol);
            string color = isTerminal ? "#2ecc71" : "#e74c3c";
            
            // Self-loop
            if (fromState == toState)
            {
                builder.OpenElement(0, "path");
                builder.AddAttribute(1, "d", $"M {x1},{y1 - stateRadius} Q {x1 + 50},{y1 - 70} {x1},{y1 - stateRadius}");
                builder.AddAttribute(2, "stroke", color);
                builder.AddAttribute(3, "stroke-width", "2");
                builder.AddAttribute(4, "fill", "none");
                builder.AddAttribute(5, "marker-end", "url(#arrowhead)");
                builder.CloseElement();
                
                builder.OpenElement(6, "text");
                builder.AddAttribute(7, "x", x1 + 25);
                builder.AddAttribute(8, "y", y1 - 60);
                builder.AddAttribute(9, "font-size", "12");
                builder.AddAttribute(10, "fill", color);
                builder.AddAttribute(11, "font-weight", "600");
                builder.AddContent(12, symbol);
                builder.CloseElement();
            }
            else
            {
                // Calculate arrow endpoint
                double angle = Math.Atan2(y2 - y1, x2 - x1);
                int endX = (int)(x2 - stateRadius * Math.Cos(angle));
                int endY = (int)(y2 - stateRadius * Math.Sin(angle));
                int startXAdjusted = (int)(x1 + stateRadius * Math.Cos(angle));
                int startYAdjusted = (int)(y1 + stateRadius * Math.Sin(angle));
                
                // Draw line
                builder.OpenElement(13, "line");
                builder.AddAttribute(14, "x1", startXAdjusted);
                builder.AddAttribute(15, "y1", startYAdjusted);
                builder.AddAttribute(16, "x2", endX);
                builder.AddAttribute(17, "y2", endY);
                builder.AddAttribute(18, "stroke", color);
                builder.AddAttribute(19, "stroke-width", "2");
                builder.AddAttribute(20, "marker-end", "url(#arrowhead)");
                builder.CloseElement();
                
                // Draw label
                int midX = (startXAdjusted + endX) / 2;
                int midY = (startYAdjusted + endY) / 2;
                
                builder.OpenElement(21, "text");
                builder.AddAttribute(22, "x", midX);
                builder.AddAttribute(23, "y", midY - 5);
                builder.AddAttribute(24, "font-size", "12");
                builder.AddAttribute(25, "fill", color);
                builder.AddAttribute(26, "font-weight", "600");
                builder.AddAttribute(27, "text-anchor", "middle");
                builder.AddContent(28, symbol);
                builder.CloseElement();
            }
        }
        
        // Draw states
        for (int i = 0; i < collection.States.Count; i++)
        {
            var (x, y) = statePositions[i];
            
            // Circle
            builder.OpenElement(29, "circle");
            builder.AddAttribute(30, "cx", x);
            builder.AddAttribute(31, "cy", y);
            builder.AddAttribute(32, "r", stateRadius);
            builder.AddAttribute(33, "fill", "#3498db");
            builder.AddAttribute(34, "stroke", "#2980b9");
            builder.AddAttribute(35, "stroke-width", "2");
            builder.CloseElement();
            
            // State number
            builder.OpenElement(36, "text");
            builder.AddAttribute(37, "x", x);
            builder.AddAttribute(38, "y", y + 5);
            builder.AddAttribute(39, "font-size", "16");
            builder.AddAttribute(40, "font-weight", "bold");
            builder.AddAttribute(41, "fill", "white");
            builder.AddAttribute(42, "text-anchor", "middle");
            builder.AddContent(43, i.ToString());
            builder.CloseElement();
        }
        
        // Arrow marker definition
        builder.OpenElement(44, "defs");
        builder.OpenElement(45, "marker");
        builder.AddAttribute(46, "id", "arrowhead");
        builder.AddAttribute(47, "markerWidth", "10");
        builder.AddAttribute(48, "markerHeight", "10");
        builder.AddAttribute(49, "refX", "9");
        builder.AddAttribute(50, "refY", "3");
        builder.AddAttribute(51, "orient", "auto");
        builder.OpenElement(52, "polygon");
        builder.AddAttribute(53, "points", "0 0, 10 3, 0 6");
        builder.AddAttribute(54, "fill", "#333");
        builder.CloseElement();
        builder.CloseElement();
        builder.CloseElement();
    };
    
    public class DFAConstructionStep
    {
        public int StateId { get; set; }
        public bool IsNewState { get; set; }
        public int ParentState { get; set; }
        public string TransitionSymbol { get; set; } = "";
        public List<int> QueueSnapshot { get; set; } = new();
        public List<string> ShiftableSymbols { get; set; } = new();
    }
    
    private void ParseCustomInput()
    {
        if (string.IsNullOrWhiteSpace(customInput))
        {
            customParseOutput = "ERROR: Input cannot be empty!";
            return;
        }
        
        try
        {
            // Initialize for custom demo mode
            isCustomDemoMode = true;
            currentStep = 1;
            isRunning = true;
            isDemoComplete = false;
            currentStateIndex = -1;
            currentTableStateIndex = -1;
            currentParseStepIndex = -1;
            customParseOutput = "";
            customDemoGrammarText = "";
            customDemoFirstSetsText = "";
            customDemoSummaryText = "";
            customDemoParseSteps.Clear();
            
            // Initialize parser
            grammar = new Grammar();
            firstComputer = new FirstSetComputer(grammar);
            operations = new LR1Operations(grammar, firstComputer);
            collection = new CanonicalCollection(grammar, operations);
            dfaSteps.Clear();
            
            // Build grammar text
            var sb = new StringBuilder();
            for (int i = 0; i < grammar.Productions.Count; i++)
            {
                sb.AppendLine($"{i}: {grammar.Productions[i]}");
            }
            customDemoGrammarText = sb.ToString();
            
            StartTimer();
        }
        catch (Exception ex)
        {
            customParseOutput = $"ERROR: {ex.Message}";
            isCustomDemoMode = false;
        }
    }
    
    private async Task AdvanceCustomStep()
    {
        await InvokeAsync(() =>
        {
            if (!isRunning) return;
            
            if (currentStep == 1)
            {
                currentStep = 2;
            }
            else if (currentStep == 2)
            {
                currentStep = 3;
                var sb = new StringBuilder();
                var firstSets = firstComputer.GetAllFirstSets();
                foreach (var nt in grammar.NonTerminals.OrderBy(x => x))
                {
                    sb.AppendLine($"FIRST({nt}) = {{ {string.Join(", ", firstSets[nt].OrderBy(x => x))} }}");
                }
                customDemoFirstSetsText = sb.ToString();
                BuildDFAWithSteps();
                currentStateIndex = 0;
            }
            else if (currentStep == 3 && currentStateIndex < collection.States.Count - 1)
            {
                currentStateIndex++;
            }
            else if (currentStep == 3)
            {
                currentStep = 4;
                parsingTable = new ParsingTable(grammar, collection);
                parsingTable.ConstructTables();
                currentTableStateIndex = 0;
            }
            else if (currentStep == 4 && currentTableStateIndex < collection.States.Count - 1)
            {
                currentTableStateIndex++;
            }
            else if (currentStep == 4)
            {
                currentStep = 5;
                var tokens = LR1Parser.Tokenize(customInput);
                var parser = new LR1Parser(grammar, parsingTable);
                customDemoParseSteps = parser.ParseWithSteps(tokens);
                currentParseStepIndex = 0;
            }
            else if (currentStep == 5 && currentParseStepIndex < customDemoParseSteps.Count - 1)
            {
                currentParseStepIndex++;
            }
            else if (currentStep == 5)
            {
                currentStep = 6;
                var sb = new StringBuilder();
                sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                sb.AppendLine($"CUSTOM INPUT: {customInput}");
                sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                sb.AppendLine();
                sb.AppendLine("PARSING RESULT:");
                sb.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
                
                if (customDemoParseSteps.Count > 0 && customDemoParseSteps.Last().Action.Type == ActionType.Accept)
                {
                    sb.AppendLine("‚úì PARSING SUCCESSFUL - INPUT ACCEPTED!");
                }
                else
                {
                    sb.AppendLine("‚úó PARSING FAILED - INPUT REJECTED!");
                }
                
                sb.AppendLine();
                sb.AppendLine("EXPLANATION:");
                sb.AppendLine("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
                sb.AppendLine("The parsing table has NO CONFLICTS, meaning this is a valid");
                sb.AppendLine("Canonical LR(1) grammar.");
                sb.AppendLine();
                sb.AppendLine("However, NO CONFLICTS ‚â† ACCEPTS ALL STRINGS");
                sb.AppendLine();
                sb.AppendLine("The grammar defines a LANGUAGE - a specific set of valid strings.");
                sb.AppendLine("The conflict-free parsing table just ensures that the parser can");
                sb.AppendLine("make unambiguous decisions when processing input.");
                sb.AppendLine();
                sb.AppendLine("If parsing fails, it means the input string is NOT in the language");
                sb.AppendLine("defined by this grammar, even though the parser itself is valid.");
                sb.AppendLine();
                sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                customDemoSummaryText = sb.ToString();
                
                isRunning = false;
                isDemoComplete = true;
                timer?.Dispose();
            }
            
            StateHasChanged();
        });
    }
}
